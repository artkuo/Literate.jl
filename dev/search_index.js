var documenterSearchIndex = {"docs":
[{"location":"generated/name/","page":"Rational numbers","title":"Rational numbers","text":"EditURL = \"../outputformats.jl\"","category":"page"},{"location":"generated/name/#Rational-numbers","page":"Rational numbers","title":"Rational numbers","text":"","category":"section"},{"location":"generated/name/","page":"Rational numbers","title":"Rational numbers","text":"In julia rational numbers can be constructed with the // operator. Lets define two rational numbers, x and y:","category":"page"},{"location":"generated/name/","page":"Rational numbers","title":"Rational numbers","text":"x = 1//3","category":"page"},{"location":"generated/name/","page":"Rational numbers","title":"Rational numbers","text":"y = 2//5","category":"page"},{"location":"generated/name/","page":"Rational numbers","title":"Rational numbers","text":"When adding x and y together we obtain a new rational number:","category":"page"},{"location":"generated/name/","page":"Rational numbers","title":"Rational numbers","text":"z = x + y","category":"page"},{"location":"pipeline/#Processing-pipeline","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"","category":"section"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"The generation of output follows the same pipeline for all output formats:","category":"page"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"Pre-processing\nParsing\nDocument generation\nPost-processing\nWriting to file","category":"page"},{"location":"pipeline/#Pre-processing","page":"3. Processing pipeline","title":"3.1. Pre-processing","text":"","category":"section"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"The first step is pre-processing of the input file. The file is read to a String. The first processing step is to apply the user specified pre-processing function, see Custom pre- and post-processing.","category":"page"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"The next step is to perform all of the built-in default replacements. CRLF style line endings (\"\\r\\n\") are replaced with LF line endings (\"\\n\") to simplify internal processing. Next, line filtering is performed, see Filtering lines, meaning that lines starting with #md, #nb or #jl are handled (either just the token itself is removed, or the full line, depending on the output target). The last pre-processing step is to expand the convenience \"macros\" described in Default replacements is expanded.","category":"page"},{"location":"pipeline/#Parsing","page":"3. Processing pipeline","title":"3.2. Parsing","text":"","category":"section"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"After the preprocessing the file is parsed. The first step is to categorize each line and mark them as either markdown or code according to the rules described in the Syntax section. Lets consider the example from the previous section with each line categorized:","category":"page"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"# # Rational numbers                                                     <- markdown\n#                                                                        <- markdown\n# In julia rational numbers can be constructed with the `//` operator.   <- markdown\n# Lets define two rational numbers, `x` and `y`:                         <- markdown\n                                                                         <- code\n## Define variable x and y                                               <- code\nx = 1 // 3                                                               <- code\ny = 2 // 5                                                               <- code\n                                                                         <- code\n# When adding `x` and `y` together we obtain a new rational number:      <- markdown\n                                                                         <- code\nz = x + y                                                                <- code","category":"page"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"In the next step the lines are grouped into \"chunks\" of markdown and code. This is done by simply collecting adjacent lines of the same \"type\" into chunks:","category":"page"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"# # Rational numbers                                                     ┐\n#                                                                        │\n# In julia rational numbers can be constructed with the `//` operator.   │ markdown\n# Lets define two rational numbers, `x` and `y`:                         ┘\n                                                                         ┐\n## Define variable x and y                                               │\nx = 1 // 3                                                               │\ny = 2 // 5                                                               │ code\n                                                                         ┘\n# When adding `x` and `y` together we obtain a new rational number:      ] markdown\n                                                                         ┐\nz = x + y                                                                ┘ code","category":"page"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"In the last parsing step all empty leading and trailing lines for each chunk are removed, but empty lines within the same block are kept. The leading # tokens are also removed from the markdown chunks. Finally we would end up with the following 4 chunks:","category":"page"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"Chunks #1:","category":"page"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"# Rational numbers\n\nIn julia rational numbers can be constructed with the `//` operator.\nLets define two rational numbers, `x` and `y`:","category":"page"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"Chunk #2:","category":"page"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"# Define variable x and y\nx = 1 // 3\ny = 2 // 5","category":"page"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"Chunk #3:","category":"page"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"When adding `x` and `y` together we obtain a new rational number:","category":"page"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"Chunk #4:","category":"page"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"z = x + y","category":"page"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"It is then up to the Document generation step to decide how these chunks should be treated.","category":"page"},{"location":"pipeline/#Custom-control-over-chunk-splits","page":"3. Processing pipeline","title":"Custom control over chunk splits","text":"","category":"section"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"Sometimes it is convenient to be able to manually control how the chunks are split. For example, if you want to split a block of code into two, such that they end up in two different @example blocks or notebook cells. The #- token can be used for this purpose. All lines starting with #- are used as \"chunk-splitters\":","category":"page"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"x = 1 // 3\ny = 2 // 5\n#-\nz = x + y","category":"page"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"The example above would result in two consecutive code-chunks.","category":"page"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"tip: Tip\nThe rest of the line, after #-, is discarded, so it is possible to use e.g. #------------- as a chunk splitter, which may make the source code more readable.","category":"page"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"It is also possible to use #+ as a chunk splitter. The difference between #+ and #- is that #+ enables Documenter's \"continued\"-blocks, see the Documenter manual.","category":"page"},{"location":"pipeline/#Document-generation","page":"3. Processing pipeline","title":"3.3. Document generation","text":"","category":"section"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"After the parsing it is time to generate the output. What is done in this step is very different depending on the output target, and it is described in more detail in the Output format sections: Markdown output, Notebook output and Script output. Using the default settings, the following is happening:","category":"page"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"Markdown output: markdown chunks are printed as-is, code chunks are put inside a code fence (defaults to @example-blocks),\nNotebook output: markdown chunks are printed in markdown cells, code chunks are put in code cells,\nScript output: markdown chunks are discarded, code chunks are printed as-is.","category":"page"},{"location":"pipeline/#Post-processing","page":"3. Processing pipeline","title":"3.4. Post-processing","text":"","category":"section"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"When the document is generated the user, again, has the option to hook-into the generation with a custom post-processing function. The reason is that one might want to change things that are only visible in the rendered document. See Custom pre- and post-processing.","category":"page"},{"location":"pipeline/#Writing-to-file","page":"3. Processing pipeline","title":"3.5. Writing to file","text":"","category":"section"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"The last step of the generation is writing to file. The result is written to $(outputdir)/$(name)(.md|.ipynb|.jl) where outputdir is the output directory supplied by the user (for example docs/generated), and name is a user supplied filename. It is recommended to add the output directory to .gitignore since the idea is that the generated documents will be generated as part of the build process rather than being files in the repo.","category":"page"},{"location":"documenter/#Interaction-with-Documenter","page":"6. Interaction with Documenter.jl","title":"6. Interaction with Documenter.jl","text":"","category":"section"},{"location":"documenter/","page":"6. Interaction with Documenter.jl","title":"6. Interaction with Documenter.jl","text":"Literate can be used for any purpose, it spits out regular markdown files, and notebooks. Typically, though, these files will be used to render documentation for your package. The generators (Literate.markdown, Literate.notebook and Literate.script) supports a keyword argument documenter that lets the generator perform some extra things, keeping in mind that the source code have been written with Documenter.jl in mind. So let's take a look at what will happen if we set documenter = true:","category":"page"},{"location":"documenter/#[Literate.markdown](@ref):","page":"6. Interaction with Documenter.jl","title":"Literate.markdown:","text":"","category":"section"},{"location":"documenter/","page":"6. Interaction with Documenter.jl","title":"6. Interaction with Documenter.jl","text":"The default code fence will change from\n```julia\n# code\n```\nto Documenters @example blocks:\n```@examples $(name)\n# code\n```\nThe following @meta block will be added to the top of the markdown page, which redirects the \"Edit on GitHub\" link on the top of the page to the source file rather than the generated .md file:\n```@meta\nEditURL = \"$(relpath(inputfile, outputdir))\"\n```","category":"page"},{"location":"documenter/#[Literate.notebook](@ref):","page":"6. Interaction with Documenter.jl","title":"Literate.notebook:","text":"","category":"section"},{"location":"documenter/","page":"6. Interaction with Documenter.jl","title":"6. Interaction with Documenter.jl","text":"Documenter style @refs and @id will be removed. This means that you can use @ref and @id in the source file without them leaking to the notebook.\nDocumenter style markdown math\n```math\n\\int f dx\n```\nis replaced with notebook compatible\n$$\n\\int f dx\n$$\nWhereas Documenter requires HTML blocks to be escaped\n```@raw html\n<tag>...</tag>\n```\nthe output to a notebook markdown cell will be raw HTML\n<tag>...</tag>","category":"page"},{"location":"documenter/#[Literate.script](@ref):","page":"6. Interaction with Documenter.jl","title":"Literate.script:","text":"","category":"section"},{"location":"documenter/","page":"6. Interaction with Documenter.jl","title":"6. Interaction with Documenter.jl","text":"Documenter style @refs and @id will be removed. This means that you can use @ref and @id in the source file without them leaking to the script.","category":"page"},{"location":"customprocessing/#Custom-pre-and-post-processing","page":"5. Custom pre- and post-processing","title":"5. Custom pre- and post-processing","text":"","category":"section"},{"location":"customprocessing/","page":"5. Custom pre- and post-processing","title":"5. Custom pre- and post-processing","text":"Since all packages are different, and may have different demands on how to create a nice example for the documentation it is important that the package maintainer does not feel limited by the by default provided syntax that this package offers. While you can generally come a long way by utilizing line filtering there might be situations where you need to manually hook into the generation and change things. In Literate this is done by letting the user supply custom pre- and post-processing functions that may do transformation of the content.","category":"page"},{"location":"customprocessing/","page":"5. Custom pre- and post-processing","title":"5. Custom pre- and post-processing","text":"All of the generators (Literate.markdown, Literate.notebook and Literate.script) accept preprocess and postprocess keyword arguments. The default \"transformation\" is the identity function. The input to the transformation functions is a String, and the output should be the transformed String.","category":"page"},{"location":"customprocessing/","page":"5. Custom pre- and post-processing","title":"5. Custom pre- and post-processing","text":"preprocess is sent the raw input that is read from the source file (modulo the default line ending transformation). postprocess is given different things depending on the output: For markdown and script output postprocess is given the content String just before writing it to the output file, but for notebook output postprocess is given the dictionary representing the notebook, since, in general, this is more useful.","category":"page"},{"location":"customprocessing/#Example:-Adding-current-date","page":"5. Custom pre- and post-processing","title":"Example: Adding current date","text":"","category":"section"},{"location":"customprocessing/","page":"5. Custom pre- and post-processing","title":"5. Custom pre- and post-processing","text":"As an example, lets say we want to splice the date of generation into the output. We could of course update our source file before generating the docs, but we could instead use a preprocess function that splices the date into the source for us. Consider the following source file:","category":"page"},{"location":"customprocessing/","page":"5. Custom pre- and post-processing","title":"5. Custom pre- and post-processing","text":"# # Example\n# This example was generated DATEOFTODAY\n\nx = 1 // 3","category":"page"},{"location":"customprocessing/","page":"5. Custom pre- and post-processing","title":"5. Custom pre- and post-processing","text":"where DATEOFTODAY is a placeholder, to make it easier for our preprocess function to find the location. Now, lets define the preprocess function, for example","category":"page"},{"location":"customprocessing/","page":"5. Custom pre- and post-processing","title":"5. Custom pre- and post-processing","text":"function update_date(content)\n    content = replace(content, \"DATEOFTODAY\" => Date(now()))\n    return content\nend","category":"page"},{"location":"customprocessing/","page":"5. Custom pre- and post-processing","title":"5. Custom pre- and post-processing","text":"which would replace every occurrence of \"DATEOFTODAY\" with the current date. We would now simply give this function to the generator, for example:","category":"page"},{"location":"customprocessing/","page":"5. Custom pre- and post-processing","title":"5. Custom pre- and post-processing","text":"Literate.markdown(\"input.jl\", \"outputdir\"; preprocess = update_date)","category":"page"},{"location":"customprocessing/#Example:-Replacing-include-calls-with-included-code","page":"5. Custom pre- and post-processing","title":"Example: Replacing include calls with included code","text":"","category":"section"},{"location":"customprocessing/","page":"5. Custom pre- and post-processing","title":"5. Custom pre- and post-processing","text":"Let's say that we have some individual example files file1, file2, ... etc. that are runnable and also following the style of Literate. These files could be for example used in the test suite of your package.","category":"page"},{"location":"customprocessing/","page":"5. Custom pre- and post-processing","title":"5. Custom pre- and post-processing","text":"We want to group them all into a single page in our documentation, but we do not want to copy paste the content of file1, ... for robustness: the files are included in the test suite and some changes may occur to them. We want these changes to also be reflected in the documentation.","category":"page"},{"location":"customprocessing/","page":"5. Custom pre- and post-processing","title":"5. Custom pre- and post-processing","text":"A very easy way to do this is using preprocess to interchange include statements with file content. First, create a runnable .jl following the format of Literate","category":"page"},{"location":"customprocessing/","page":"5. Custom pre- and post-processing","title":"5. Custom pre- and post-processing","text":"# # Replace includes\n# This is an example to replace `include` calls with the actual file content.\n\ninclude(\"file1.jl\")\n\n# Cool, we just saw the result of the above code snippet. Here is one more:\n\ninclude(\"file2.jl\")","category":"page"},{"location":"customprocessing/","page":"5. Custom pre- and post-processing","title":"5. Custom pre- and post-processing","text":"Let's say we have saved this file as examples.jl. Then, you want to properly define a pre-processing function:","category":"page"},{"location":"customprocessing/","page":"5. Custom pre- and post-processing","title":"5. Custom pre- and post-processing","text":"function replace_includes(str)\n\n    included = [\"file1.jl\", \"file2.jl\"]\n\n    # Here the path loads the files from their proper directory,\n    # which may not be the directory of the `examples.jl` file!\n    path = \"directory/to/example/files/\"\n\n    for ex in included\n        content = read(path*ex, String)\n        str = replace(str, \"include(\\\"$(ex)\\\")\" => content)\n    end\n    return str\nend","category":"page"},{"location":"customprocessing/","page":"5. Custom pre- and post-processing","title":"5. Custom pre- and post-processing","text":"(of course replace included with your respective files)","category":"page"},{"location":"customprocessing/","page":"5. Custom pre- and post-processing","title":"5. Custom pre- and post-processing","text":"Finally, you simply pass this function to e.g. Literate.markdown as","category":"page"},{"location":"customprocessing/","page":"5. Custom pre- and post-processing","title":"5. Custom pre- and post-processing","text":"Literate.markdown(\"examples.jl\", \"path/to/save/markdown\";\n                  name = \"markdown_file_name\", preprocess = replace_includes)","category":"page"},{"location":"customprocessing/","page":"5. Custom pre- and post-processing","title":"5. Custom pre- and post-processing","text":"and you will see that in the final output file (here markdown_file_name.md) the include statements are replaced with the actual code to be included!","category":"page"},{"location":"customprocessing/","page":"5. Custom pre- and post-processing","title":"5. Custom pre- and post-processing","text":"This approach is used for generating the examples in the documentation of the TimeseriesPrediction.jl package. The  example files, included together in the  stexamples.jl file, are processed by literate via this make.jl  file to generate the markdown and code cells of the documentation.","category":"page"},{"location":"outputformats/#Output-formats","page":"4. Output formats","title":"4. Output formats","text":"","category":"section"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"When the source is parsed, and has been processed it is time to render the output. We will consider the following source snippet:","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"import Markdown\nMarkdown.parse(\"```julia\\n\" * rstrip(read(\"outputformats.jl\", String)) * \"\\n```\")","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"and see how this is rendered in each of the output formats.","category":"page"},{"location":"outputformats/#Markdown-output","page":"4. Output formats","title":"4.1. Markdown output","text":"","category":"section"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"Markdown output is generated by Literate.markdown. There exist various \"flavors\" of markdown and Literate supports some different flavors, see Markdown flavors. The default flavor is Literate.DocumenterFlavor() and, as the name suggest, it generates markdown files meant to be used together with Documenter.jl. The output of the source snippet above is as follows:","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"import Markdown\nfile = joinpath(@__DIR__, \"../src/generated/name.md\")\nstr = \"`````markdown\\n\" * rstrip(read(file, String)) * \"\\n`````\"\nrm(file)\nMarkdown.parse(str)","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"We note that lines starting with # are printed as regular markdown, and the code lines have been wrapped in @example blocks. We also note that an @meta block have been added, that sets the EditURL variable. This is used by Documenter to redirect the \"Edit on GitHub\" link for the page, see Interaction with Documenter.","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"The @example blocks are wrapped in 4 consecutive backticks so as to allow for docstrings containing triple backticks, for example:","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"\"\"\"\nThis function perform the following calculation:\n```math\n    x_1 + x_2\n```\n\"\"\"\nf(x) = x[1] + x[2]","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"If your Julia code itself contains 4 consecutive backticks, you can use the keyword argument codefence to setup 5 backticks for code blocks, see Configuration.","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"It possible to configure Literate.markdown to also evaluate code snippets, capture the result and include it in the output, by passing execute=true as a keyword argument. The result of the first code-block in the example above would then become","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"````julia\nx = 1//3\n````\n````\n1//3\n````","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"In this example the output is just plain text. However, if the resulting value of the code block can be displayed as an image (image/png or image/jpeg), HTML (text/html) or markdown (text/markdown) Literate will include the richest representation of the output.","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"note: Note\nSince Documenter executes and captures results of @example block it is not necessary to use execute=true for markdown output that is meant to be used as input to Documenter.","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"See the section about Configuration for more information about how to configure the behavior and resulting output of Literate.markdown.","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"Literate.markdown","category":"page"},{"location":"outputformats/#Literate.markdown","page":"4. Output formats","title":"Literate.markdown","text":"Literate.markdown(inputfile, outputdir=pwd(); config::AbstractDict=Dict(), kwargs...)\n\nGenerate a markdown file from inputfile and write the result to the directory outputdir.\n\nSee the manual section on Configuration for documentation of possible configuration with config and other keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"outputformats/#Markdown-flavors","page":"4. Output formats","title":"Markdown flavors","text":"","category":"section"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"Literate can output markdown in different flavors. The flavor is specified using the flavor keyword argument. The following flavors are currently supported:","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"flavor = Literate.DocumenterFlavor(): this is the default flavor and the output is meant to be used as input to Documenter.jl.\nflavor = Literate.CommonMarkFlavor(): this outputs markdown that has the flavor of the CommonMark specification.\nflavor = Literate.FranklinFlavor(): this outputs markdown meant to be used as input to Franklin.jl.","category":"page"},{"location":"outputformats/#Notebook-output","page":"4. Output formats","title":"4.2. Notebook output","text":"","category":"section"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"Notebook output is generated by Literate.notebook. The (default) notebook output of the source snippet can be seen here: notebook.ipynb.","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"We note that lines starting with # are placed in markdown cells, and the code lines have been placed in code cells. By default the notebook is also executed and output cells populated. The current working directory is set to the specified output directory the notebook is executed.","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"See the section about Configuration for how to configure the behavior and resulting output of Literate.notebook.","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"Literate.notebook","category":"page"},{"location":"outputformats/#Literate.notebook","page":"4. Output formats","title":"Literate.notebook","text":"Literate.notebook(inputfile, outputdir=pwd(); config::AbstractDict=Dict(), kwargs...)\n\nGenerate a notebook from inputfile and write the result to outputdir.\n\nSee the manual section on Configuration for documentation of possible configuration with config and other keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"outputformats/#Notebook-metadata","page":"4. Output formats","title":"Notebook metadata","text":"","category":"section"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"Jupyter notebook cells (both code cells and markdown cells) can contain metadata. This is enabled in Literate by the %% token, similar to Jupytext. The format is as follows","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"%% optional ignored text [type] {optional metadata JSON}","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"Cell metadata can, for example, be used for nbgrader and the reveal.js notebook extension RISE.","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"The following would create a 3 slide deck with RISE:","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"#nb # %% A slide [markdown] {\"slideshow\": {\"slide_type\": \"slide\"}}\n# # Some title\n#\n# We're using `#nb` so the metadata is only included in notebook output\n\n#nb %% A slide [code] {\"slideshow\": {\"slide_type\": \"fragment\"}}\nx = 1//3\ny = 2//5\n\n#nb # %% A slide [markdown] {\"slideshow\": {\"slide_type\": \"subslide\"}}\n# For more information about RISE, see [the docs](https://rise.readthedocs.io/en/stable/usage.html)","category":"page"},{"location":"outputformats/#Script-output","page":"4. Output formats","title":"4.3. Script output","text":"","category":"section"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"Script output is generated by Literate.script. The (default) script output of the source snippet above is as follows:","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"import Markdown\nfile = joinpath(@__DIR__,  \"../src/generated/outputformats.jl\")\nstr = \"```julia\\n\" * rstrip(read(file, String)) * \"\\n```\"\nrm(file)\nMarkdown.parse(str)","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"We note that lines starting with # are removed and only the code lines have been kept.","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"See the section about Configuration for how to configure the behavior and resulting output of Literate.script.","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"Literate.script","category":"page"},{"location":"outputformats/#Literate.script","page":"4. Output formats","title":"Literate.script","text":"Literate.script(inputfile, outputdir=pwd(); config::AbstractDict=Dict(), kwargs...)\n\nGenerate a plain script file from inputfile and write the result to outputdir.\n\nSee the manual section on Configuration for documentation of possible configuration with config and other keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"outputformats/#Configuration","page":"4. Output formats","title":"4.4. Configuration","text":"","category":"section"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"The behavior of Literate.markdown, Literate.notebook and Literate.script can be configured by keyword arguments. There are two ways to do this; pass config::Dict as a keyword argument, or pass individual keyword arguments.","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"note: Configuration precedence\nIndividual keyword arguments take precedence over the config dictionary, so for e.g. Literate.markdown(...; config = Dict(\"name\" => \"hello\"), name = \"world\") the resulting configuration for name will be \"world\". Both individual keyword arguments and the config dictionary take precedence over the default.","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"Available configurations with description and default values are given in the reference for Literate.DEFAULT_CONFIGURATION just below.","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"Literate.DEFAULT_CONFIGURATION","category":"page"},{"location":"outputformats/#Literate.DEFAULT_CONFIGURATION","page":"4. Output formats","title":"Literate.DEFAULT_CONFIGURATION","text":"DEFAULT_CONFIGURATION\n\nDefault configuration for Literate.markdown, Literate.notebook and Literate.script which is used for everything not specified by the user. Configuration can be passed as individual keyword arguments or as a dictionary passed with the config keyword argument. See the manual section about Configuration for more information.\n\nAvailable options:\n\nname (default: filename(inputfile)): Name of the output file (excluding the file extension).\npreprocess (default: identity): Custom preprocessing function mapping a String to a String. See Custom pre- and post-processing.\npostprocess (default: identity): Custom preprocessing function mapping a String to a String. See Custom pre- and post-processing.\ncredit (default: true): Boolean for controlling the addition of This file was generated with Literate.jl ... to the bottom of the page. If you find Literate.jl useful then feel free to keep this.\nkeep_comments (default: false): When true, keeps markdown lines as comments in the output script. Only applicable for Literate.script.\nexecute (default: true for notebook, false for markdown): Whether to execute and capture the output. Only applicable for Literate.notebook and Literate.markdown.\ncodefence (default: \"````@example $(name)\" => \"````\" for DocumenterFlavor() and \"````julia\" => \"````\" otherwise): Pair containing opening and closing code fence for wrapping code blocks.\nflavor (default: Literate.DocumenterFlavor()) Output flavor for markdown, see Markdown flavors. Only applicable for Literate.markdown.\ndevurl (default: \"dev\"): URL for \"in-development\" docs, see Documenter docs. Unused if repo_root_url/ nbviewer_root_url/binder_root_url are set.\nsoftscope (default: true for Jupyter notebooks, false otherwise): enable/disable \"soft\" scoping rules when executing, see e.g. https://github.com/JuliaLang/SoftGlobalScope.jl.\nrepo_root_url: URL to the root of the repository. Determined automatically on Travis CI, GitHub Actions and GitLab CI. Used for @__REPO_ROOT_URL__.\nnbviewer_root_url: URL to the root of the repository as seen on nbviewer. Determined automatically on Travis CI, GitHub Actions and GitLab CI. Used for @__NBVIEWER_ROOT_URL__.\nbinder_root_url: URL to the root of the repository as seen on mybinder. Determined automatically on Travis CI, GitHub Actions and GitLab CI. Used for @__BINDER_ROOT_URL__.\nimage_formats: A vector of (mime, ext) tuples, with the default Tuple{MIME, String}[(MIME type image/svg+xml, \".svg\"), (MIME type image/png, \".png\"), (MIME type image/jpeg, \".jpeg\")]. Results which are showable with a MIME type are saved with the first match, with the corresponding extension.\n\n\n\n\n\n","category":"constant"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Literate","category":"page"},{"location":"reference/#Literate","page":"Reference","title":"Literate","text":"Literate\n\nJulia package for Literate Programming. See https://fredrikekre.github.io/Literate.jl/ for documentation.\n\n\n\n\n\n","category":"module"},{"location":"fileformat/#File-format","page":"2. File format","title":"2. File format","text":"","category":"section"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"The source file format for Literate is a regular, commented, julia (.jl) scripts. The idea is that the scripts also serve as documentation on their own and it is also simple to include them in the test-suite, with e.g. include, to make sure the examples stay up to date with other changes in your package.","category":"page"},{"location":"fileformat/#Syntax","page":"2. File format","title":"2.1. Syntax","text":"","category":"section"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"The basic syntax is simple:","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"lines starting with # are treated as markdown,\nall other lines are treated as julia code.","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"Leading whitespace is allowed before #, but it will be removed when generating the output. Since #-lines are treated as markdown we can not use that for regular julia comments, for this you can instead use ##, which will render as # in the output.","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"Lets look at a simple example:","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"# # Rational numbers\n#\n# In julia rational numbers can be constructed with the `//` operator.\n# Lets define two rational numbers, `x` and `y`:\n\n## Define variable x and y\nx = 1//3\ny = 2//5\n\n# When adding `x` and `y` together we obtain a new rational number:\n\nz = x + y","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"In the lines starting with # we can use regular markdown syntax, for example the # used for the heading and the backticks for formatting code. The other lines are regular julia code. We note a couple of things:","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"The script is valid julia, which means that we can include it and the example will run (for example in the test/runtests.jl script, to include the example in the test suite).\nThe script is \"self-explanatory\", i.e. the markdown lines works as comments and thus serve as good documentation on its own.","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"For simple use this is all you need to know. The following additional special syntax can also be used:","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"#md, #nb, #jl, #src: tags to filter lines, see Filtering lines,\n#- (#+): tag to manually control chunk-splits, see Custom control over chunk splits.","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"There is also some default convenience replacements that will always be performed, see Default replacements.","category":"page"},{"location":"fileformat/#Multiline-comments-and-markdown-strings","page":"2. File format","title":"Multiline comments and markdown strings","text":"","category":"section"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"Literate version 2.7 adds support for Julia multiline comments for markdown input. All multiline comments in the input are rewritten to regular comments as part of the preprocessing step, before any other processing is performed. For Literate to recognize multiline comments it is required that the start token (#=) and end token (=#) are placed on their own lines. Note also that it is allowed to have more than one = in the tokens, for example","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"#=\nThis multiline comment\nis treated as markdown.\n=#\n\n#=====================\nThis is also markdown.\n=====================#","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"is rewritten to","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"# This multiline comment\n# is treated as markdown.\n\n# This is also markdown.","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"Similarly, Literate version 2.9 adds support for using literal markdown strings, md\"\"\" ... \"\"\", for the markdown sections, for example","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"md\"\"\"\n# Title\nblah blah blah\n\"\"\"","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"is rewritten to","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"# # Title\n# blah blah blah","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"This is not enabled by default – it requires passing mdstrings=true. Literate.markdown/Literate.notebook/Literate.script.","category":"page"},{"location":"fileformat/#Filtering-lines","page":"2. File format","title":"2.2. Filtering lines","text":"","category":"section"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"It is often useful to filter out lines in the source depending on the output format. For this purpose there are a number of \"tokens\" that can be used to mark the purpose of certain lines:","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"#md: line exclusive to markdown output,\n#nb: line exclusive to notebook output,\n#jl: line exclusive to script output,\n#src: line exclusive to the source code and thus filtered out unconditionally.","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"Lines starting or ending with one of these tokens are filtered out in the preprocessing step. In addition, for markdown output, lines ending with #hide are filtered out similar to Documenter.jl.","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"note: Difference between `#src` and `#hide`\n#src and #hide are quite similar. The only difference is that #src lines are filtered out before execution (if execute=true) and #hide lines are filtered out after execution.","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"tip: Tip\nThe tokens can also be negated, for example a line starting with #!nb would be included in markdown and script output, but filtered out for notebook output.","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"Suppose, for example, that we want to include a docstring within a @docs block using Documenter. Obviously we don't want to include this in the notebook, since @docs is Documenter syntax that the notebook will not understand. This is a case where we can prepend #md to those lines:","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"#md # ```@docs\n#md # Literate.markdown\n#md # Literate.notebook\n#md # Literate.script\n#md # ```","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"The lines in the example above would be filtered out in the preprocessing step, unless we are generating a markdown file. When generating a markdown file we would simply remove the leading #md from the lines. Beware that the space after the tag is also removed.","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"The #src token can also be placed at the end of a line. This is to make it possible to have code lines exclusive to the source code, and not just comment lines. For example, if the source file is included in the test suite we might want to add a @test at the end without this showing up in the outputs:","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"using Test                      #src\n@test result == expected_result #src","category":"page"},{"location":"fileformat/#Default-replacements","page":"2. File format","title":"2.3. Default replacements","text":"","category":"section"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"The following convenience \"macros\"/source placeholders are always expanded:","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"@__NAME__:\nexpands to the name keyword argument to Literate.markdown, Literate.notebook and Literate.script (defaults to the filename of the input file).\n@__REPO_ROOT_URL__:\nCan be used to link to files in the repository. For example @__REPO_ROOT_URL__/src/Literate.jl would link to the source of the Literate module. This variable is automatically determined on Travis CI, GitHub Actions and GitLab CI, but can be configured, see Configuration.\n@__NBVIEWER_ROOT_URL__:\nCan be used if you want a link that opens the generated notebook in http://nbviewer.jupyter.org/. This variable is automatically determined on Travis CI, GitHub Actions and GitLab CI, but can be configured, see Configuration.\n@__BINDER_ROOT_URL__:\nCan be used if you want a link that opens the generated notebook in https://mybinder.org/. For example, to add a binder-badge in e.g. the HTML output you can use:\n[![Binder](https://mybinder.org/badge_logo.svg)](@__BINDER_ROOT_URL__/path/to/notebook.inpynb)\nThis variable is automatically determined on Travis CI, GitHub Actions and GitLab CI, but can be configured, see Configuration.","category":"page"},{"location":"#Introduction","page":"1. Introduction","title":"1. Introduction","text":"","category":"section"},{"location":"","page":"1. Introduction","title":"1. Introduction","text":"Welcome to the documentation for Literate  – a simplistic package for Literate Programming.","category":"page"},{"location":"#What?","page":"1. Introduction","title":"What?","text":"","category":"section"},{"location":"","page":"1. Introduction","title":"1. Introduction","text":"Literate is a package that generates markdown pages (for e.g. Documenter.jl), and Jupyter notebooks, from the same source file. There is also an option to \"clean\" the source from all metadata, and produce a pure Julia script.","category":"page"},{"location":"","page":"1. Introduction","title":"1. Introduction","text":"The main design goal is simplicity. It should be simple to use, and the syntax should be simple. In short, all you have to do is to write a commented julia script!","category":"page"},{"location":"","page":"1. Introduction","title":"1. Introduction","text":"The public interface consists of three functions, all of which take the same script file as input, but generate different output:","category":"page"},{"location":"","page":"1. Introduction","title":"1. Introduction","text":"Literate.markdown generates a markdown file. Code snippets can be executed and the results included in the output.\nLiterate.notebook generates a notebook. Code snippets can be executed and the results included in the output.\nLiterate.script generates a plain script file scrubbed from all metadata and special syntax.","category":"page"},{"location":"#Why?","page":"1. Introduction","title":"Why?","text":"","category":"section"},{"location":"","page":"1. Introduction","title":"1. Introduction","text":"Examples are (probably) the best way to showcase your awesome package, and examples are often the best way for a new user to learn how to use it. It is therefore important that the documentation of your package contains examples for users to read and study. However, people are different, and we all prefer different ways of trying out a new package. Some people want to RTFM, others want to explore the package interactively in, for example, a notebook, and some people want to study the source code. The aim of Literate is to make it easy to give the user all of these options, while still keeping maintenance to a minimum.","category":"page"},{"location":"","page":"1. Introduction","title":"1. Introduction","text":"It is quite common that packages have \"example notebooks\" to showcase the package. Notebooks are great for showcasing a package, but they are not so great with version control, like git. The reason being that a notebook is a very \"rich\" format since it contains output and other metadata. Changes to the notebook thus result in large diffs, which makes it harder to review the actual changes.","category":"page"},{"location":"","page":"1. Introduction","title":"1. Introduction","text":"It is also common that packages include examples in the documentation, for example by using Documenter.jl @example-blocks. This is also great, but it is not quite as interactive as a notebook, for the users who prefer that.","category":"page"},{"location":"","page":"1. Introduction","title":"1. Introduction","text":"Literate tries to solve the problems above by creating the output as a part of the doc build. Literate generates the output based on a single source file which makes it easier to maintain, test, and keep the manual and your example notebooks in sync.","category":"page"},{"location":"tips/#tips-and-tricks","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"","category":"section"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"This section lists some tips and tricks that might be useful for using Literate.","category":"page"},{"location":"tips/#notebook-filesize","page":"7. Tips and tricks","title":"Filesize of generated notebooks","text":"","category":"section"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"When Literate executes a notebook the return value, i.e. the result of the last Julia expression in each cell is captured. By default Literate generates multiple renderings of the result in different output formats or MIMEs, just like IJulia.jl does. All of these renderings are embedded in the notebook and it is up to the notebook frontend viewer to select the most appropriate format to show to the user.","category":"page"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"A common example is images, which can often be displayed in multiple formats, e.g. PNG (image/png), SVG (image/svg+xml) and HTML (text/html). As a result, the filesize of the generated notebook can become large.","category":"page"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"In order to remedy this you can use the clever Julia package DisplayAs to limit the output capabilities of an object. For example, to \"force\" an image to be captures as image/png only, you can use","category":"page"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"import DisplayAs\nimg = plot(...)\nimg = DisplayAs.PNG(img)","category":"page"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"This can save some memory, since the image is never captured in e.g. SVG or HTML formats.","category":"page"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"note: Note\nIt is best to always let the object be showable as text/plain. This can be achieved by nested calls to DisplayAs output types. For example, to limit an image img to be showable as just image/png and text/plain you can useimg = plot(...)\nimg = DisplayAs.Text(DisplayAs.PNG(img))","category":"page"},{"location":"tips/#printing-tables-in-markdown","page":"7. Tips and tricks","title":"Printing tables in Markdown","text":"","category":"section"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"Tables that support the Tables.jl interface can be included in Markdown output with the lightweight package MarkdownTables.jl.","category":"page"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"using MarkdownTables\ntable = [(a = 1, b = 2), (a = 3, b = 4)]\ntable |> markdown_table()","category":"page"},{"location":"tips/#admonitions-md","page":"7. Tips and tricks","title":"Adding admonitions using compound line filtering","text":"","category":"section"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"Admonitions are a useful feature for drawing attention to particular elements of  documentation. They are documented in Documenter.jl and an example of their use can be seen above in the blue 'note' box. Admonitions is a specific Julia markdown feature, and they are not recognized by either common mark or Jupyter notebooks. The md line filter can be used to make sure admonitions only show up in markdown output, for example:","category":"page"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"#md # !!! note \"Be aware!\"\n#md #     This a note style admonition!","category":"page"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"It is important to note that both #md and the second # are required. Literate.jl interprets the first #md as a markdown exclusive line, and then strips it out. The  second # tells Literate.jl that the line should be parsed as markdown and not a  Julia code block. If you only include #md and not the second # then it will  be parsed into Julia example block in the final documentation and not an actual  admonition.","category":"page"},{"location":"tips/#admonitions-compatibility","page":"7. Tips and tricks","title":"Custom parsing for markdown and notebook compatible admonitions","text":"","category":"section"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"As mentioned above, admonitions are not compatible with Jupyter notebooks. (Though at time of writing this documentation, this is an open issue in Jupyter so may change in the future.) For now, we can write a custom preprocessor function so that admonitions are interpreted as quotes (with their own special formatting) in notebooks and proper admonitions in markdown. For the case of note admonitions, this can be written as follows:","category":"page"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"function md_note(str)\n    str = replace(str, r\"^#note # (.*)$\"m => s\"\"\"\n    # !!! note\n    #     \\1\"\"\")\n    return str\nend\n\nfunction nb_note(str)\n    str = replace(str, r\"^#note # (.*)$\"m => s\"\"\"\n    # > *Note*\n    # > \\1\"\"\")\n    return str\nend\n\nusing Literate\n\nLiterate.markdown(\"example.jl\", \"tmp/\"; preprocess = md_note)\n\nLiterate.notebook(\"example.jl\", \"tmp/\"; preprocess = nb_note)","category":"page"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"This will allow us to turn the following source code in example.jl:","category":"page"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"#note # This is a useful note.","category":"page"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"into the correct admonition syntax in the markdown file generated:","category":"page"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"!!! note\n    This is a useful note.","category":"page"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"and a quotation style formatting in the generated notebook cell:","category":"page"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"> *Note*\n> This is a useful note.","category":"page"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"which, in an actual notebook cell, will look similar to:","category":"page"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"Note\nThis is a useful note.","category":"page"},{"location":"tips/#debug-execution","page":"7. Tips and tricks","title":"Debugging code execution","text":"","category":"section"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"When Literate is executing code (i.e. when execute = true is set), it does so quietly. All the output gets captured and nothing gets printed into the terminal. This can make it tricky to know where things go wrong, e.g. when the execution stalls due to an infinite loop.","category":"page"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"To help debug this, Literate has an @debug statement that prints out each code block that is being executed. In general, to enable the printing of Literate's @debug statements, you can set the JULIA_DEBUG environment variable to \"Literate\".","category":"page"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"The easiest way to do that is to set the variable in the Julia session before running Literate by doing","category":"page"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"ENV[\"JULIA_DEBUG\"]=\"Literate\"","category":"page"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"Alternatively, you can also set the environment variable before starting the Julia session, e.g.","category":"page"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"$ JULIA_DEBUG=Literate julia","category":"page"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"or by wrapping the Literate calls in an withenv block","category":"page"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"withenv(\"JULIA_DEBUG\" => \"Literate\") do\n    Literate.notebook(\"myscript.jl\"; execute=true)\nend","category":"page"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"EditURL = \"../../../examples/example.jl\"","category":"page"},{"location":"generated/example/#**8.**-Example","page":"8. Example","title":"8. Example","text":"","category":"section"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"(Image: ) (Image: )","category":"page"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"This is an example generated with Literate based on this source file: example.jl. You are seeing the HTML-output which Documenter has generated based on a markdown file generated with Literate. The corresponding notebook can be viewed in nbviewer here: example.ipynb, and opened in binder here: example.ipynb, and the plain script output can be found here: example.jl.","category":"page"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"It is recommended to have the source file available when reading this, to better understand how the syntax in the source file corresponds to the output you are seeing.","category":"page"},{"location":"generated/example/#Basic-syntax","page":"8. Example","title":"Basic syntax","text":"","category":"section"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"The basic syntax for Literate is simple, lines starting with # is interpreted as markdown, and all the other lines are interpreted as code. Here is some code:","category":"page"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"x = 1//3\ny = 2//5","category":"page"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"In markdown sections we can use markdown syntax. For example, we can write text in italic font, text in bold font and use links.","category":"page"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"It is possible to filter out lines depending on the output using the #md, #nb, #jl and #src tags (see Filtering lines):","category":"page"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"This line starts with #md and is thus only visible in the markdown output.","category":"page"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"The source file is parsed in chunks of markdown and code. Starting a line with #- manually inserts a chunk break. For example, if we want to display the output of the following operations we may insert #- in between. These two code blocks will now end up in different @example-blocks in the markdown output, and two different notebook cells in the notebook output.","category":"page"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"x + y","category":"page"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"x * y","category":"page"},{"location":"generated/example/#Output-capturing","page":"8. Example","title":"Output capturing","text":"","category":"section"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"Code chunks are by default placed in Documenter @example blocks in the generated markdown. This means that the output will be captured in a block when Documenter is building the docs. In notebooks the output is captured in output cells, if the execute keyword argument is set to true. Output to stdout/stderr is also captured.","category":"page"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"note: Note\nNote that Documenter currently only displays output to stdout/stderr if there is no other result to show. Since the vector [1, 2, 3, 4] is returned from foo, the printing of \"This string is printed to stdout.\" is hidden.","category":"page"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"function foo()\n    println(\"This string is printed to stdout.\")\n    return [1, 2, 3, 4]\nend\n\nfoo()","category":"page"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"Just like in the REPL, outputs ending with a semicolon hides the output:","category":"page"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"1 + 1;\nnothing #hide","category":"page"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"Both Documenter's @example block and notebooks can display images. Here is an example where we generate a simple plot using the Plots.jl package","category":"page"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"using Plots\nx = range(0, stop=6π, length=1000)\ny1 = sin.(x)\ny2 = cos.(x)\nplot(x, [y1, y2])","category":"page"},{"location":"generated/example/#Custom-processing","page":"8. Example","title":"Custom processing","text":"","category":"section"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"It is possible to give Literate custom pre- and post-processing functions. For example, here we insert a placeholder value y = 321 in the source, and use a preprocessing function that replaces it with y = 321 in the rendered output.","category":"page"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"x = 123","category":"page"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"In this case the preprocessing function is defined by","category":"page"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"function pre(s::String)\n    s = replace(s, \"x = 123\" => \"y = 321\")\n    return s\nend","category":"page"},{"location":"generated/example/#documenter-interaction","page":"8. Example","title":"Documenter.jl interaction","text":"","category":"section"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"In the source file it is possible to use Documenter.jl style references, such as @ref and @id. These will be filtered out in the notebook output. For example, here is a link, but it is only visible as a link if you are reading the markdown output. We can also use equations:","category":"page"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"int_Omega nabla v cdot nabla u mathrmdOmega = int_Omega v f mathrmdOmega","category":"page"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"using Documenters math syntax. Documenters syntax is automatically changed to \\begin{equation} ... \\end{equation} in the notebook output to display correctly.","category":"page"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"","category":"page"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"This page was generated using Literate.jl.","category":"page"}]
}
